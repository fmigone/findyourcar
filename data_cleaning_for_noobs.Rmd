---
title: "data_cleaning_for_noobs"
author: "gg"
date: "11/19/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Warning : built over one dataset. Surely other datasets will pose many problems but it's the beginning of a solution here.

## Data Cleaning

#### Libraries import
```{r}
library(tidyverse)
library(magrittr)
library(readr)
library(stringr)
library(lubridate)

Sys.setlocale(locale="en_US.UTF-8")
```

#### Read data and primary data cleaning

Read the data (in the future, we will have to rbind all the scrapped listings - a function should do):

```{r}
mapping_villes <- data.frame(read_csv2("datasets/mapping_villes.csv"))

data <- read_csv("datasets/scrapped_listings_1_1_500.csv")

#todo:

#function that reads and rowbinds the list of csv

#assign all to data
```

Remove the deleted listings, and the useless column that is X1:

```{r}
data <- data %>% 
  filter(is_listing_deleted == 0) %>% 
  select(-X1, -is_listing_deleted)

data <- data.frame(data)

#View(data)
```

#### URL

We keep URL.

#### Brand

```{r}

# To check over other datasets, but for now it seems occasion is mentioned every time, so let's just remove it

# sum(sapply(data$brand, function(x) str_detect(x, "occasion"))) / length(data$brand)

# Actual cleaning

data$brand <- sapply(data$brand, function(x) str_remove(x, " occasion")[1], USE.NAMES = F)

# Check

#data %>% 
#  distinct(brand)

# Good, we reduced the brand column to their actual brand names
```

#### Modèle

For now, let's just consider that the modèle is an additional information but not a category, as in one we would use in our filtering or models.

#### Adresse pro / particulier

For now, we will focus on retrieving the postal code from the address and the city from mapping_villes.csv (source : http://www.nosdonnees.fr/wiki/index.php/Fichier:EUCircos_Regions_departements_circonscriptions_communes_gps.csv.gz)

We'll use a regular expression to find the postal code : "(([0-8][0-9])|(9[0-5])|(2[ab]))[0-9]{3}"


```{r}
# Combine address particulier and pro : coalesce takes the first value, but if null, imputes the second value

data$all_address <- coalesce(data$address_particulier, data$address_pro)

get_postal_code <- function(address) {
  # Get all the strings that match a possible postal code
  poss_postal_codes <- str_match_all(address, "(([0-8][0-9])|(9[0-5])|(2[ab]))[0-9]{3}")[[1]][,1]
  l <- length(poss_postal_codes)
  # If there isn't any, return NA
  if (l == 0) {
    NA
  }
  # If there is just one, good, we keep that one
  else if (l == 1) {
     poss_postal_codes[1]
  } 
  # If there are many, we test them again, considering that scenario : we have both a postal box (BP) and a postal code. We want the one that is most likely to be a postal code (should usually end with a 0), and keep that one.
  # Note: we don't use that for everything because some postal codes end don't end with 0, ex in Paris : 75001.
  else {
    better_postal_code <- str_match(poss_postal_codes, "(([0-8][0-9])|(9[0-5])|(2[ab]))[0-9]{2}[0]")[,1]
    better_postal_code[!is.na(better_postal_code)]
    }
}

data$postal_codes <- sapply(data$all_address, get_postal_code, USE.NAMES = F)
```

ATTENTION S'ARRÊTER LÀ : PLUSIEURS VILLES PAR CODES POSTAUX
REPRENDRE ICI...

Il faut récupérer les villes en parsant les strings puis faire un join sur code postal et ville.
+ Trouver une manière de faire un join "loose" qui ne prenne pas en compte espaces, casse, etc
Le parsing se fera différemment selon si pro ou particulier -> soit partir des deux colonnes, soit utiliser le "is_pro" plus bas.

#### Join on long, lat and city

It's not the most efficient thing to do codewise, surely, but it does ensure that we'll have the same format for everything.

```{r}
# Filter the information we're interested in
relevant_mapping_villes <- mapping_villes %>% 
  select(code_région, nom_région, numéro_département, nom_département, nom_commune, codes_postaux, latitude, longitude)

relevant_mapping_villes %>% 
  group_by(codes_postaux)

dim(relevant_mapping_villes)

# Join with postal codes

# NE FONCTIONNE PAS !

#test <- inner_join(x = data[1,], y = relevant_mapping_villes, by= c("postal_codes" = "codes_postaux"))
#distinct(test)
```

#### Name pro + is pro

Name pro will be useful only when the seller is a pro. Let's just keep it that way and create an "is_pro" binary column for easy access to this information.

```{r}
data$is_pro <- (1 - is.na(data$name_pro))
```

#### Année


/!\ Ne fonctionne pas !!!! Fonctionne sur des dates individuelles mais pas sur toute la colonne, je n'ai pas réussi à gérer le bugs

```{r}
# sapply(data$Année, function(x) str_detect(x, "Assurance auto : Comparez"), USE.NAMES = F)

# We either have NA or something that includes " Assurance auto : Comparez" : let's remove it.
# Then our objective is to get a date object

french_months <- c(
                   "janvier", 
                   "février", 
                   "mars", 
                   "avril",
                   "mai",
                   "juin",
                   "juillet",
                   "août",
                   "septembre",
                   "octobre",
                   "novembre",
                   "décembre"
                   )

clean_month_year <- function(my) {
  my = str_remove(my, "\nAssurance auto : Comparez")
  my_split <- str_split(my, " ")[[1]]
  if (all(is.na(my_split))) {
    NA
  }
  else if (length(my_split) == 1) {
    ymd(str_c(y_split_test, "-01-01"))
  }
  else if (length(my_split) == 2) {
    ymd(
      str_c(
        my_split[2],
        "-",
        str_pad(
          string = as.character(
            which(
              french_months %in% str_to_lower(my_split)[1]
              )
            ), width = 2, pad = "0"),
        "-01"
        )
      )
  }
  else { NA }
}

clean_month_year(data$Année[200])

str_remove(my, "\nAssurance auto : Comparez")

data$Année[1]

# C'est ça qui ne marche pas : normalement je l'assignerais à une colonne de data mais là marche pas...
test <- sapply(data$Année, clean_month_year, USE.NAMES = F)
class(test[1])
```

#### Carrosserie

```{r}
# Check distinct items
data %>% distinct(Carrosserie)
```

It seems quite clean already, nothing to add.

#### Consommation mixte

```{r}
# Let's just remove the "litre / 100 km" part that is at the end of each line.

data$cons_mixte_l_by_100km <- sapply(data$Consommation.mixte, function(x) str_remove(x, "\nlitres / 100 km")[1], USE.NAMES = F)

# OK, it works

```

#### Emissions de CO2

```{r}
# Let's just remove the "litre / 100 km" part that is at the end of each line.

data$emissions_co2_g_by_km <- sapply(data$Emissions.de.CO2, function(x) str_remove(x, "\ng/km")[1], USE.NAMES = F)
data %>% distinct(emissions_co2_g_by_km)

# OK, it works
```

#### Energie

```{r}
# Just creating an identical energie column with the right name 
colnames(data)[colnames(data)=="Energie"] <- "energie"
```

#### Etat du véhicule

```{r}
colnames(data)[colnames(data)=="Etat.du.véhicule"] <- "etat_vehicule"
```

#### Kilométrage

```{r}
data$kilometrage_km <- sapply(data$Kilométrage, function(x) str_remove(str_remove(x, "\nkm")," ")[1], USE.NAMES = F)
```

#### Nombre de portes

```{r}
# Faire 2 colonnes : une pour le nombre de portes une pour le hayon 
data %>% distinct(Nb.de.portes)
data$nb_portes <- sapply(data$Nb.de.portes, function(x) str_remove(str_remove(x, " avec hayon"),c(" portes"))[1], USE.NAMES = F)
data %>% distinct(nb_portes)

data$hayon <- sapply(data$Nb.de.portes, function(x) str_detect(x, "hayon")*1)
```

#### Nombre de places

```{r}
data$nb_places <- sapply(data$Nombre.de.places, function(x) str_remove(x, "\nplaces")[1], USE.NAMES = F)
```

#### Prix

```{r}
data$prix <- sapply(data$Prix, function(x) str_remove(str_remove(x, " €"), " ")[1], USE.NAMES = F)
```

#### Puissance fiscale

```{r}
data$puissance_fiscale_cv <- sapply(data$Puissance.fiscale, function(x) str_remove(x, "\nCV")[1], USE.NAMES = F)
```

#### Puissance réelle

```{r}
data$puissance_reelle_ch <- sapply(data$Puissance.réelle, function(x) str_remove(x, "\nCh")[1], USE.NAMES = F)
```

#### Transmission

```{r}
colnames(data)[colnames(data)=="Transmission"] <- "transmission"
```

#### Garantie mécanique

```{r}
data$garantie_mecanique_mois <- sapply(data$Garantie.mécanique, function(x) str_remove(x, " mois")[1], USE.NAMES = F)
```

#### V1

```{r}
# Only NA : do we want to get it out?
data %>% distinct(V1)
```

#### Contrôle technique

```{r}
colnames(data)[colnames(data)=="Contrôle.technique"] <- "controle_technique"

# Créer des dummies ?
data %>% distinct(controle_technique)
```

#### Couleur intérieur

```{r}
colnames(data)[colnames(data)=="Couleur.intérieur"] <- "couleur_interieur"
```

#### Type de peinture carrosserie

```{r}
colnames(data)[colnames(data)=="Type.de.peinture.carrosserie"] <- "type_peinture_carrosserie"
```

#### Option Equipement Sécurité

```{r}
data$abs <- sapply(data$Option.equipement.Sécurité, function(x) str_detect(x, "ABS")*1)
data$esp <- sapply(data$Option.equipement.Sécurité, function(x) str_detect(x, "ESP")*1)
data$regulateur_vitesse <- sapply(data$Option.equipement.Sécurité, function(x) str_detect(x, "Régulateur de vitesse")*1)
data$asr <- sapply(data$Option.equipement.Sécurité, function(x) str_detect(x, "ASR")*1)
data$alarme_antivol <- sapply(data$Option.equipement.Sécurité, function(x) str_detect(x, "Alarme antivol")*1)
data %>% distinct(abs,esp, asr, alarme_antivol, regulateur_vitesse,Option.equipement.Sécurité)

# Beaucoup de NA, on va surement jeter
```

#### Option Equipement Confort Intérieur

```{r}
data$direction_assistee <- sapply(data$Option.Equipement.Confort.intérieur, function(x) str_detect(x, "Direction assistée")*1)
data$banquette_ar <- sapply(data$Option.Equipement.Confort.intérieur, function(x) str_detect(x, "Banquette AR 1/3 - 2/3")*1)
data$radio_cd <- sapply(data$Option.Equipement.Confort.intérieur, function(x) str_detect(x, "Radio/CD")*1)
data$fermeture_centralisee <- sapply(data$Option.Equipement.Confort.intérieur, function(x) str_detect(x, "Fermeture centralisée")*1)
data$vitres_electriques <- sapply(data$Option.Equipement.Confort.intérieur, function(x) str_detect(x, "Vitres électriques")*1)

data %>% distinct(Option.Equipement.Confort.intérieur, direction_assistee, banquette_ar,radio_cd, fermeture_centralisee, vitres_electriques)

# Beaucoup de NA, on va surement jeter
```

#### Option Equipement Exterieurs

```{r}

data$allumage_auto_feux <- sapply(data$Option.equipement.extérieurs, function(x) str_detect(x, "Allumage automatique des feux")*1)
data$peinture_metallisee <- sapply(data$Option.equipement.extérieurs, function(x) str_detect(x, "Peinture métallisée")*1)
data$retroviseurs_electriques <- sapply(data$Option.equipement.extérieurs, function(x) str_detect(x, "Rétroviseurs électriques")*1)
data$roues_alliage_léger <- sapply(data$Option.equipement.extérieurs, function(x) str_detect(x, "Roues alliage léger")*1)
data$fap <- sapply(data$Option.equipement.extérieurs, function(x) str_detect(x, "FAP")*1)

data %>% distinct(Option.equipement.extérieurs, allumage_auto_feux, peinture_metallisee,retroviseurs_electriques, roues_alliage_léger, fap)


```


```{r}
new_data %>% names()
new_data <- data %>% select(-Kilométrage,-Puissance.fiscale,-Puissance.réelle,-Garantie.mécanique,-Option.equipement.Sécurité,-Option.Equipement.Confort.intérieur,-Option.equipement.extérieurs,-V1,-Nb.de.portes,-Nombre.de.places,-Consommation.mixte,-Emissions.de.CO2)
```


#### A faire : toutes les colonnes suivantes

Selon la convention : noms de variables en minuscules, en anglais, sans espace, avec "_"
Pour les valeurs numériques : préciser les unités dans le nom de colonne
Ex : Consommation.mixte / "6.5 litres / 100 km" (première valeur)
devient "cons_mixte_l_by_100km" / 6.5