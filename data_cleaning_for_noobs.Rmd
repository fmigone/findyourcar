---
title: "data_cleaning_for_noobs"
author: "gg"
date: "11/19/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Warning : built over one dataset. Surely other datasets will pose many problems but it's the beginning of a solution here.

## Data Cleaning

#### Libraries import
```{r}
library(tidyverse)
library(magrittr)
library(readr)
library(stringr)
library(lubridate)

Sys.setlocale(locale="en_US.UTF-8")
```

#### Read data and primary data cleaning

Read the data (in the future, we will have to rbind all the scrapped listings - a function should do):

```{r}
mapping_villes <- data.frame(read_csv2("datasets/mapping_villes.csv"))

data <- read_csv("datasets/scrapped_listings_1_1_500.csv")

#todo:

#function that reads and rowbinds the list of csv

#assign all to data
```

Remove the deleted listings, and the useless column that is X1:

```{r}
data <- data %>% 
  filter(is_listing_deleted == 0) %>% 
  select(-X1, -is_listing_deleted)

data <- data.frame(data)

#View(data)
```

#### URL

We keep URL.

#### Brand

```{r}

# To check over other datasets, but for now it seems occasion is mentioned every time, so let's just remove it

# sum(sapply(data$brand, function(x) str_detect(x, "occasion"))) / length(data$brand)

# Actual cleaning

data$brand <- sapply(data$brand, function(x) str_remove(x, " occasion")[1], USE.NAMES = F)

# Check

#data %>% 
#  distinct(brand)

# Good, we reduced the brand column to their actual brand names
```

#### Modèle

For now, let's just consider that the modèle is an additional information but not a category, as in one we would use in our filtering or models.

#### Adresse pro / particulier

For now, we will focus on retrieving the postal code from the address and the city from mapping_villes.csv (source : http://www.nosdonnees.fr/wiki/index.php/Fichier:EUCircos_Regions_departements_circonscriptions_communes_gps.csv.gz)

We'll use a regular expression to find the postal code : "(([0-8][0-9])|(9[0-5])|(2[ab]))[0-9]{3}"


```{r}
# Combine address particulier and pro : coalesce takes the first value, but if null, imputes the second value

data$all_address <- coalesce(data$address_particulier, data$address_pro)

get_postal_code <- function(address) {
  # Get all the strings that match a possible postal code
  poss_postal_codes <- str_match_all(address, "(([0-8][0-9])|(9[0-5])|(2[ab]))[0-9]{3}")[[1]][,1]
  l <- length(poss_postal_codes)
  # If there isn't any, return NA
  if (l == 0) {
    NA
  }
  # If there is just one, good, we keep that one
  else if (l == 1) {
     poss_postal_codes[1]
  } 
  # If there are many, we test them again, considering that scenario : we have both a postal box (BP) and a postal code. We want the one that is most likely to be a postal code (should usually end with a 0), and keep that one.
  # Note: we don't use that for everything because some postal codes end don't end with 0, ex in Paris : 75001.
  else {
    better_postal_code <- str_match(poss_postal_codes, "(([0-8][0-9])|(9[0-5])|(2[ab]))[0-9]{2}[0]")[,1]
    better_postal_code[!is.na(better_postal_code)]
    }
}

data$postal_codes <- sapply(data$all_address, get_postal_code, USE.NAMES = F)
```

ATTENTION S'ARRÊTER LÀ : PLUSIEURS VILLES PAR CODES POSTAUX
REPRENDRE ICI...

Il faut récupérer les villes en parsant les strings puis faire un join sur code postal et ville.
+ Trouver une manière de faire un join "loose" qui ne prenne pas en compte espaces, casse, etc
Le parsing se fera différemment selon si pro ou particulier -> soit partir des deux colonnes, soit utiliser le "is_pro" plus bas.

#### Join on long, lat and city

It's not the most efficient thing to do codewise, surely, but it does ensure that we'll have the same format for everything.

```{r}
# Filter the information we're interested in
relevant_mapping_villes <- mapping_villes %>% 
  select(code_région, nom_région, numéro_département, nom_département, nom_commune, codes_postaux, latitude, longitude)

relevant_mapping_villes %>% 
  group_by(codes_postaux)

dim(relevant_mapping_villes)

# Join with postal codes

# NE FONCTIONNE PAS !

#test <- inner_join(x = data[1,], y = relevant_mapping_villes, by= c("postal_codes" = "codes_postaux"))
#distinct(test)
```

#### Name pro + is pro

Name pro will be useful only when the seller is a pro. Let's just keep it that way and create an "is_pro" binary column for easy access to this information.

```{r}
data$is_pro <- (1 - is.na(data$name_pro))
```

#### Année


/!\ Ne fonctionne pas !!!! Fonctionne sur des dates individuelles mais pas sur toute la colonne, je n'ai pas réussi à gérer le bugs

```{r}
# sapply(data$Année, function(x) str_detect(x, "Assurance auto : Comparez"), USE.NAMES = F)

# We either have NA or something that includes " Assurance auto : Comparez" : let's remove it.
# Then our objective is to get a date object

french_months <- c(
                   "janvier", 
                   "février", 
                   "mars", 
                   "avril",
                   "mai",
                   "juin",
                   "juillet",
                   "août",
                   "septembre",
                   "octobre",
                   "novembre",
                   "décembre"
                   )

clean_month_year <- function(my) {
  my = str_remove(my, "\nAssurance auto : Comparez")
  my_split <- str_split(my, " ")[[1]]
  if (all(is.na(my_split))) {
    NA
  }
  else if (length(my_split) == 1) {
    ymd(str_c(y_split_test, "-01-01"))
  }
  else if (length(my_split) == 2) {
    ymd(
      str_c(
        my_split[2],
        "-",
        str_pad(
          string = as.character(
            which(
              french_months %in% str_to_lower(my_split)[1]
              )
            ), width = 2, pad = "0"),
        "-01"
        )
      )
  }
  else { NA }
}

clean_month_year(data$Année[200])

str_remove(my, "\nAssurance auto : Comparez")

data$Année[1]

# C'est ça qui ne marche pas : normalement je l'assignerais à une colonne de data mais là marche pas...
test <- sapply(data$Année, clean_month_year, USE.NAMES = F)
class(test[1])
```


#### A faire : toutes les colonnes suivantes

Selon la convention : noms de variables en minuscules, en anglais, sans espace, avec "_"
Pour les valeurs numériques : préciser les unités dans le nom de colonne
Ex : Consommation.mixte / "6.5 litres / 100 km" (première valeur)
devient "cons_mixte_l_by_100km" / 6.5